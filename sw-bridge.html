<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Service Worker Bridge</title>
</head>
<body>
<script>
// Service Worker Bridge - handles cross-origin communication for SW status checks
// This page is loaded in a hidden iframe from the platform settings page

const ALLOWED_ORIGINS = [
    'https://battle-buddy-games.github.io',
    // Allow any trycloudflare.com tunnel
    /^https:\/\/[a-z0-9-]+\.trycloudflare\.com$/,
    // Allow localhost for development
    /^https?:\/\/localhost(:\d+)?$/,
    /^https?:\/\/127\.0\.0\.1(:\d+)?$/,
    // Allow local network IPs
    /^https?:\/\/192\.168\.\d+\.\d+(:\d+)?$/,
    /^https?:\/\/10\.\d+\.\d+\.\d+(:\d+)?$/
];

function isAllowedOrigin(origin) {
    return ALLOWED_ORIGINS.some(allowed => {
        if (typeof allowed === 'string') {
            return origin === allowed;
        }
        return allowed.test(origin);
    });
}

// IndexedDB helpers for reading tunnel data
const DB_NAME = 'PlatformTunnelDB';
const DB_VERSION = 1;
const STORE_NAME = 'tunnels';

function openTunnelDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const store = db.createObjectStore(STORE_NAME, { keyPath: 'address' });
                store.createIndex('lastSeen', 'lastSeen', { unique: false });
                store.createIndex('name', 'name', { unique: false });
            }
        };
    });
}

async function getKnownTunnels() {
    try {
        const db = await openTunnelDB();
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result || []);
            request.onerror = () => reject(request.error);
        });
    } catch (e) {
        console.warn('[SW Bridge] Failed to get tunnels:', e);
        return [];
    }
}

async function getSwVersion() {
    if (!navigator.serviceWorker?.controller) {
        // Try to find active SW registration
        const registrations = await navigator.serviceWorker.getRegistrations();
        const swReg = registrations.find(r => r.active?.scriptURL?.includes('platform-sw.js'));
        if (!swReg?.active) {
            return null;
        }
        return new Promise((resolve) => {
            const channel = new MessageChannel();
            channel.port1.onmessage = (event) => resolve(event.data?.version || null);
            swReg.active.postMessage({ type: 'GET_SW_VERSION' }, [channel.port2]);
            setTimeout(() => resolve(null), 2000);
        });
    }
    return new Promise((resolve) => {
        const channel = new MessageChannel();
        channel.port1.onmessage = (event) => resolve(event.data?.version || null);
        navigator.serviceWorker.controller.postMessage({ type: 'GET_SW_VERSION' }, [channel.port2]);
        setTimeout(() => resolve(null), 2000);
    });
}

async function checkSwInstalled() {
    if (!('serviceWorker' in navigator)) {
        return { isInstalled: false, reason: 'not_supported' };
    }
    try {
        const registrations = await navigator.serviceWorker.getRegistrations();
        const platformSw = registrations.find(r =>
            r.active?.scriptURL?.includes('platform-sw.js') ||
            r.installing?.scriptURL?.includes('platform-sw.js') ||
            r.waiting?.scriptURL?.includes('platform-sw.js')
        );
        if (platformSw) {
            const version = await getSwVersion();
            return { isInstalled: true, scope: platformSw.scope, version };
        }
        return { isInstalled: false, reason: 'not_registered' };
    } catch (e) {
        return { isInstalled: false, reason: 'error', error: e.message };
    }
}

async function uninstallSw() {
    if (!('serviceWorker' in navigator)) {
        return { success: false, error: 'Service workers not supported' };
    }
    try {
        const registrations = await navigator.serviceWorker.getRegistrations();
        for (const registration of registrations) {
            if (registration.active?.scriptURL?.includes('platform-sw.js') ||
                registration.installing?.scriptURL?.includes('platform-sw.js') ||
                registration.waiting?.scriptURL?.includes('platform-sw.js')) {
                await registration.unregister();
            }
        }
        // Clear the localStorage flag
        try {
            localStorage.removeItem('platform_sw_installed');
        } catch (e) {}
        return { success: true };
    } catch (e) {
        return { success: false, error: e.message };
    }
}

// Handle incoming messages
window.addEventListener('message', async (event) => {
    if (!isAllowedOrigin(event.origin)) {
        console.warn('[SW Bridge] Rejected message from:', event.origin);
        return;
    }

    const { type, requestId } = event.data || {};
    if (!type) return;

    let response = { requestId };

    try {
        switch (type) {
            case 'GET_SW_STATUS':
                const status = await checkSwInstalled();
                response = { ...response, ...status };
                break;

            case 'GET_KNOWN_TUNNELS':
                const tunnels = await getKnownTunnels();
                response = { ...response, success: true, tunnels };
                break;

            case 'UNINSTALL_SW':
                const result = await uninstallSw();
                response = { ...response, ...result };
                break;

            default:
                response = { ...response, error: 'Unknown message type' };
        }
    } catch (e) {
        response = { ...response, error: e.message };
    }

    event.source.postMessage(response, event.origin);
});

// Notify parent that bridge is ready
if (window.parent !== window) {
    window.parent.postMessage({ type: 'SW_BRIDGE_READY' }, '*');
}
</script>
</body>
</html>
